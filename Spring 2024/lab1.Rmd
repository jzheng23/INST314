---
title: "Lab 1: Introduction to R and Data Management"
subtitle: "DUE Feb 2"
author: 
date: 
output: pdf_document
---

# Some Initial R Basics

You can use R to do basic math commands. Try doing the following commands line by line.

```{r,results='hide'}
1+3 # addition
2*4 # multiplication
10/2 # division
3^2 # exponentiation
```

Notice that we have some text describing what we're doing after a "#" sign. This is called **commenting** your code, and the "#" tells R to ignore everything on the line that comes afterwards. This is useful for keeping notes on what you do in R. 

## Objects

R is an object-oriented language. This means that the language is centered around objects rather than actions. Consider the following code.

```{r}
a <- 3
```

The "`<-`" symbols assign the value of 3 to "`a`" (notice that it looks like an arrow, showing the assignment). Now, we have an object "`a`" that contains the value of 3. Now try running the following code. What do you think will happen?

```{r, results='hide'}
a + 2
```

## Vectors

In R, we will work with vectors. Vectors are an ordered collection of a certain type of object. You can use the "`c()`" function to create vectors.

```{r, results='hide'}
numvector <- c(1,4,6,7)
numvector
```

Recall that the assignment in the first line doesn't actually output anything -- it just does the assignment. In order to see what was put into "`numvector`", we need to run the second line. 

To make a vector of sequential numbers, we can use a colon.

```{r, results='hide'}
1:10 # This is a vector from 1 to 10.
```

We can do this with other types of variables, like strings. Strings are just text data, which we can make by using quotation marks.

```{r, results='hide'}
stringvector <- c("test","strings", "this is some text")
stringvector
```

Finally, to access different elements of a vector, you can use square brackets. Note that R starts indexing at 1, NOT at 0. 

```{r, results='hide'}
stringvector[2] # This is the second element of stringvector
```

# Exploring Email Data

The textbook for this course has an accompanying `R` package called `openintro` that has all the data sets used in the examples. Packages, or libraries, in R are basically bundles of useful tools that other people have created for you to download and use. We can use the `install.packages()` function to install it on our computers.

```{r install, results='hide',message=FALSE, eval=FALSE}
# If you haven't installed the openintro package yet, do so first!
install.packages('openintro')
```

To load the package that we just installed, we can use either the `require()` or `library()` function.

```{r libraries, results='hide',message=FALSE}
require(openintro)
```

This needs to be done every session (that is, every time you open up R again) if you want to use the tools inside the `openintro` package. Typically, the first thing you put in an R script is a list of packages you want to bring in.  

Now that we've loaded the `openintro` package, let's bring in the `email` dataset. The `data()` function loads in a dataset that are inside the package. 

```{r emaildata, results='hide',warning=FALSE}
data(email)
```

Now that we've done this, we have a Data Frame object called `email`. You can look at the top few rows of the dataset using the `head()` function.

```{r head, results='hide',warning=FALSE}
head(email)
```

You can use the help function get more information about the variables in the data set.

```{r helpfile}
help("email")
```

If we want to look at the structure of the `email` data frame, we can use `str()`.

```{r, results='hide'}
str(email)
```

This can help you determine types of variables, but be careful! Just because a variable has numbers doesn't mean it's a numerical variable!

We can check the number of rows and columns with the following commands:

```{r, results='hide'}
nrow(email) # this is for the number of rows
ncol(email) # this is for the number of columns
dim(email) # this is for the dimensions (rows, columns)
```

## Accessing Values in a Data Frame object

We can access specific rows and columns in the data frame using square brackets. 

```{r, results = 'hide'}
email[2,3] # this gets the third variable of the second observation
```

To look at individual columns, we can either leave the rows section blank or we can use "`$`" notation. Note that these are vectors in R.

```{r,results='hide'}
# All of these do the same thing
email$spam
email[,1]
email[,"spam"]
```

If you want to look at multiple columns, we can do that by including a vector of numbers (representing column number) or a vector of column names. We can look at multiple rows by including a vector of rows, representing row numbers, as well.

```{r, results='hide'}
email[1:10, 2:4] # For columns 2 to 4
email[1:10, c("to_multiple","from","cc")] # This does the same thing
```

## Creating Subsets of the Data

Many times, especially with larger datasets, you'll want to only look at certain portions of the data. We can subset our dataset by indicating which rows we want. We do this using a vector of boolean values with `TRUE` whenever it's a row that we want and `FALSE` whenever it's a row we don't want. This vector should have a length equal to the number of rows in the data frame. To get this vector, we can just use a logical operator. For example, consider the following code.

```{r, results='hide'}
email$spam == 0 
```

This evaluates every element of the `email$spam` vector and returns a vector of the same length with `TRUE` and `FALSE` values. We can then use this vector to subset the dataset so that we only have the rows with `TRUE` values.

```{r, results='hide'}
nospam <- email[email$spam == 0,]
head(nospam)
```

The new object we've created, `nospam`, is a data frame that contains only the rows from `email` with a value of 0 in `spam`. We can also use other logical operators to create different subsets. 

```{r, results='hide'}
# What do you think this subset is?
example_subset <- email[email$spam == 0 & email$line_breaks < 10,]
head(example_subset)
```

The following table shows a list of some logical operators you might find useful.

|Operator|Meaning|
|---|---|---|---|
|>|greater than|
| >= | greater than or equal to |
|<|less than|
| <= | less than or equal to |
| == | equal to |
| != | not equal to |
| & | and |
| \| | or |

## A Note on Data Manipulation Tools

So far, all of the data manipulation has been done in base `R`. There is a very popular suite of packages called the `tidyverse`, which has tools for data manipulation (`dplyr)`, graphing (`ggplot2`) and more. They all are based on the same underlying design philosophy and grammar, making many of the tasks you'll have to do easier to read (in my opinion). In fact, these are so popular that they might nowadays almost be the default way of handling data.

You don't necessarily need to use the `tidyverse` suite of packages in this course, but I highly recommend it, not only for the future, but also just in terms of ease of learning. I will 

## Using `dplyr`

Recall that I mentioned "grammar" in using these tools. The idea behind these packages is that we have our dataset (in our case, a data frame object), which is the noun, and actions we can perform with that dataset, which is the verb. Here, I will introduce a few useful verbs for manipulating datasets.

### Subsetting rows using `filter`

`filter()` is the basic way of subsetting the data frame by selecting certain rows. 

```{r, results='hide',message=FALSE}
# First make sure you install and load dplyr!
# install.package('dplyr')
require(dplyr)
nospam2 <- filter(email, spam == 0)
head(nospam2)
```

Note that we have "`spam == 0`" and not "`email$spam == 0`".

To filter based on more than one criteria, we can just add more arguments. This does the same thing as subsetting by the "`&`" of the two conditions.

```{r, results='hide'}
nospam2 <- filter(email, spam == 0, to_multiple == 0)
# This does the same thing as:
# nospam2 <- email[email$spam == 0 & email$to_multiple == 0,]
head(nospam2)
```

### Subsetting by column with `select()`

You can subset the dataset by column using the `select()` function (some of you might note that this is the same terminology used in SQL). 

```{r, results='hide'}
head(select(email, spam, to_multiple))
```

### Re-ordering rows with `arrange()`

Sometimes, we want to re-order our dataset by a certain variable. To do this, we can use `arrange()`.

```{r, results='hide'}
arrange(email, line_breaks)
```

This changes the order of the email data frame so that it is in increasing order of the `line_breaks` variable. If we wanted descending order, we could have used `desc()`.

```{r, results='hide'}
arrange(email, desc(line_breaks))
```

### Using Pipes

Sometimes, we want to do many of these actions at the same time. For example, if we want to take a subset of rows, select only a few columns, then re-order the dataset, we might do something like this:

```{r, results='hide'}
# What would this do?
newemail <- arrange(
  select(
    filter(email,spam == 0),
    spam, to_multiple, from, cc, line_breaks),
  line_breaks)
head(newemail)
```

This filters the email data frame to contain only rows with `spam == 0`, then selects only the `spam`, `to_multiple`, `from`, `cc`, and `line_breaks` columsn, then arranges it by `line_breaks` in increasing order. Unfortunately, this is very hard to read.

To make everything more readable, `dplyr` brings in the `%>%` operator from the `magrittr` package (you don't need to worry about the `magrittr` package for now). `x %>% f(y)` turns into `f(x,y)`, so we can pipe in functions one at a time to make the code more readable. Instead of having to read the code inside out, we can read it sequentially to see what it is doing.

Let's see it in action using the example we used above.

```{r, results='hide'}
# This does the same as above!
newemail <- email %>% 
  filter(spam == 0) %>% 
  select(spam, to_multiple, from, cc, line_breaks) %>% 
  arrange(line_breaks)
head(newemail)
```

This takes the `email` data frame, does the filtering on `spam`, selects the variables we want, then arranges by `line_breaks`. In this way, we have our "noun" data frame, `email`, first, then all of the "verbs", or functions, are written in their order of execution. . 

# Exploring Our Own Datasets

You can also use R to bring in datasets from CSV files on your computer. First, make sure to download the file on your computer. Then, edit the first line below to reflect the location of where you downloaded the file and run the code.

```{r, results='hide'}
# Make sure to edit the path!
filepath <- '/Users/bkim/Downloads/MillionSongsFinal.csv'
songs <- read.csv(filepath)
head(songs)
```

Let's break down some of the pieces of what we just did. First, we create a string object called "`filepath`" that contains the location of our file. Then, we included it as an argument for the "`read.csv()`" function. This function reads the CSV file and outputs a data frame containing the information in that file. Then, we use "`head()`" to look at the first few rows to make sure it's been brought in properly.  

Try exploring this dataset like we've done with the `email` dataset. Then, answer the following the questions:

## Questions

For each of the questions, make sure you include all relevant code used to reach the answer.

#### 1) What is the unit of observation?

#### 2) How many variables are there?

#### 3) How many observations are there?

#### 4) What are the types of each variable? You can check the data description file for more information about each variable in the Million Songs dataset.

#### 5) Suppose we want to look at the relationship between mode and tempo for classic pop and rock songs. Subset the data so that we have only the relevant information. 

#### 6) What are the five fastest songs and five slowest songs in the dataset?
